/////////////////////////////////////////////////////
//
//  // HEADER //
//
//  FILE NAME = axi_mdrv.svh
//  ENGINEER  = Muskan
//  VERSION   = 1.0 
//  DESCRIPTION = contains all macro 
//
/////////////////////////////////////////////////////

`ifndef AXI_MDRV
`define AXI_MDRV

class axi_mdrv #(int DATA_WIDTH = 16 , ADD_WIDTH = 8) extends uvm_driver #(axi_mseq_item #(DATA_WIDTH, ADD_WIDTH));

   `uvm_component_param_utils(axi_mdrv #(DATA_WIDTH, ADD_WIDTH))
  
    virtual axi_minf #(DATA_WIDTH, ADD_WIDTH) mvif;
  
    axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) mseq_item;
    axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) pending_transaction_wadr[$];
    axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) pending_transaction_wdata[$];
    axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) pending_transaction_radr[$];

   function new (string name = "axi_mdrv", uvm_component parent = null);
      super.new(name,parent);
   endfunction
  
  task run_phase (uvm_phase phase);
  fork 
    forever begin 
      seq_item_port.get( mseq_item );
      if ( mseq_item.operation == SIM_WR ) begin
      pending_transaction_wadr.push_back(mseq_item);
      pending_transaction_radr.push_back(mseq_item);
      pending_transaction_wdata.push_back(mseq_item);
      end

      else if ( mseq_item.operation == WRITE ) begin 
      pending_transaction_wadr.push_back(mseq_item);
      pending_transaction_wdata.push_back(mseq_item); 
      end

      else 
      pending_transaction_radr.push_back(mseq_item); 

    end 
  join_none
     send_to_dut();
  endtask 

  task send_to_dut ();
       fork
       send_write_address();
       send_read_address();
       send_write_data();
       sample_write_response();
       sample_read_response();
       join
  endtask
  
  task send_write_address ( );
  axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) req;
  forever begin
      
      wait (pending_transaction_wadr.size() > 0);
      
      @(posedge mvif.MDRV_MP.aclk) begin

      if(mvif.MDRV_MP.mdrv_cb.awvalid == 1'b1)
          wait (mvif.MDRV_MP.mdrv_cb.awready == 1'b1);

      req = pending_transaction_wadr.pop_front();
      // We can have an callback method for some delay ( to send data before address )
      mvif.MDRV_MP.mdrv_cb.awid    <= req.awid;
      mvif.MDRV_MP.mdrv_cb.awaddr  <= req.awaddr;
      mvif.MDRV_MP.mdrv_cb.awlen   <= req.awlen;
      mvif.MDRV_MP.mdrv_cb.awsize  <= req.awsize;
      mvif.MDRV_MP.mdrv_cb.awburst <= req.awburst;
      mvif.MDRV_MP.mdrv_cb.awvalid <= 1'b1;
      // mvif.MDRV_MP.mdrv_cb.bready <= 1'b1; // correct or not ?? // TODO       

      if ( pending_transaction_wadr.size() == 0 )begin 
          wait (mvif.MDRV_MP.mdrv_cb.awready == 1'b1);
         @(posedge mvif.MDRV_MP.aclk) mvif.MDRV_MP.mdrv_cb.awvalid <= 1'b0; end
      end
      end 
  endtask
   
  task send_read_address ( );
  axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) req;

  forever begin
      wait (pending_transaction_radr.size() > 0);
      
      @(posedge mvif.MDRV_MP.aclk) begin
      
      if(mvif.MDRV_MP.mdrv_cb.arvalid == 1'b1)
          wait (mvif.MDRV_MP.mdrv_cb.arready == 1'b1);
      
      req = pending_transaction_radr.pop_front();
      mvif.MDRV_MP.mdrv_cb.arid    <= req.arid;
      mvif.MDRV_MP.mdrv_cb.araddr  <= req.araddr;
      mvif.MDRV_MP.mdrv_cb.arlen   <= req.arlen;
      mvif.MDRV_MP.mdrv_cb.arsize  <= req.arsize;
      mvif.MDRV_MP.mdrv_cb.arburst <= req.arburst;
      mvif.MDRV_MP.mdrv_cb.arvalid <= 1'b1;
      
      if ( pending_transaction_radr.size() == 0 )begin 
          wait (mvif.MDRV_MP.mdrv_cb.arready == 1'b1);
        @(posedge mvif.MDRV_MP.aclk) mvif.MDRV_MP.mdrv_cb.arvalid <= 1'b0; end

     end
   end
  endtask

  task send_write_data ( );
  axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) req;

  forever
    begin
      wait (pending_transaction_wdata.size() > 0);
      
      @(posedge mvif.MDRV_MP.aclk) begin
      req = pending_transaction_wdata.pop_front();
      
      while(req.wdata.size() > 0 ) begin
      if(mvif.MDRV_MP.mdrv_cb.wvalid == 1'b1)
          wait (mvif.MDRV_MP.mdrv_cb.wready == 1'b1);
      mvif.MDRV_MP.mdrv_cb.wid     <= req.wid;
      mvif.MDRV_MP.mdrv_cb.wvalid  <= 1'b1;

      mvif.MDRV_MP.mdrv_cb.wdata   <= req.wdata.pop_front();
      mvif.MDRV_MP.mdrv_cb.wstrb   <= req.wstrb.pop_front();
      
      if ( req.wdata.size() == 0 )  mvif.MDRV_MP.mdrv_cb.wlast   <= 1'b1; 
      else mvif.MDRV_MP.mdrv_cb.wlast   <= 1'b0; 
      
      if (req.wdata.size() > 0 ) @(posedge mvif.MDRV_MP.aclk);
     end
     end
      if ( pending_transaction_wdata.size() == 0 ) begin
          wait (mvif.MDRV_MP.mdrv_cb.wready == 1'b1);
        @(posedge mvif.MDRV_MP.aclk) mvif.MDRV_MP.mdrv_cb.wvalid  <= 1'b0;
     end 
    end
  endtask

  task sample_write_response ( );
  axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) rsp;
  
  forever begin 
      @(posedge mvif.MDRV_MP.aclk) begin
      @(negedge mvif.MDRV_MP.mdrv_cb.wlast) mvif.MDRV_MP.mdrv_cb.bready <= 1'b1; 
      // Callback method to add delay for bready 
      if( mvif.MDRV_MP.mdrv_cb.bvalid && mvif.MDRV_MP.mdrv_cb.bready ) begin // TODO
      rsp       = new("rsp");
      rsp.bid   = mvif.MDRV_MP.mdrv_cb.bid;
      rsp.bresp = mvif.MDRV_MP.mdrv_cb.bresp;
      end
      // Send responce back to sequence  
    end
    end
  endtask

  task sample_read_response ( );
  axi_mseq_item #(DATA_WIDTH,ADD_WIDTH) rsp;
  
  forever begin 
      @(posedge mvif.MDRV_MP.aclk) begin

      if( mvif.MDRV_MP.mdrv_cb.rvalid && mvif.MDRV_MP.mdrv_cb.rready ) begin
      rsp       = new("rsp");
      rsp.rid   = mvif.MDRV_MP.mdrv_cb.rid;
      
      do begin
      if ( rsp.rresp.size > 0 ) @(posedge mvif.MDRV_MP.aclk); 
      rsp.rresp.push_back(mvif.MDRV_MP.mdrv_cb.rresp);
      rsp.rdata.push_back(mvif.MDRV_MP.mdrv_cb.rdata); 
      end
      while (mvif.MDRV_MP.mdrv_cb.rlast);
      // Send responce back to sequence  
      end
     end 
   end  
  endtask


endclass 

`endif
